{"version":3,"sources":["maquette.js","../../../../src/maquette.ts"],"names":["createDom","updateDom","NAMESPACE_W3","NAMESPACE_SVG","NAMESPACE_XLINK","emptyArray","extend","base","overrides","result","Object","keys","forEach","key","same","vnode1","vnode2","vnodeSelector","properties","bind","toTextVNode","data","undefined","children","text","toString","domNode","appendChildren","parentSelector","insertions","main","i","length_1","length","item","Array","isArray","hasOwnProperty","push","missingTransition","Error","DEFAULT_PROJECTION_OPTIONS","namespace","eventHandlerInterceptor","styleApplyer","styleName","value","style","transitions","enter","exit","applyDefaultProjectionOptions","projectorOptions","checkStyleValue","styleValue","setProperties","projectionOptions","propNames","propCount","_loop_1","propName","propValue","split","token","classList","add","classNames","classNameCount","j","className","styleNames","styleCount","type","lastIndexOf","oldPropValue","evt","target","apply","this","setAttributeNS","setAttribute","updateProperties","previousProperties","propertiesUpdated","previousValue","on","previousOn","remove","newStyleValue","oldStyleValue","domValue","removeAttribute","findIndexOfChild","sameAs","start","nodeAdded","vNode","enterAnimation","nodeToRemove","exitAnimation","pointerEvents","removeDomNode","parentNode","removeChild","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","node","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","textUpdated","oldChild","newChild","findOldIndex","addChildren","initPropertiesAndChildren","textContent","afterCreate","insertBefore","c","found","document","createTextNode","appendChild","charAt","slice","id","createElementNS","createElement","previous","updated","newVNode","replaceChild","firstChild","afterUpdate","updateAnimation","createProjection","update","updatedVnode","exports","h","selector","arguments","childIndex","argsLength","onlyChild","child","dom","create","append","beforeNode","merge","element","replace","createCache","cachedInputs","cachedOutcome","invalidate","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","results","map","newSources","newKeys","oldTargets","source","sourceKey","searchIndex","createProjector","projector","propertyName","eventHandler","scheduleRender","scheduled","renderCompleted","stopped","projections","renderFunctions","doRender","renderNow","requestAnimationFrame","stop","cancelAnimationFrame","resume","renderMaquetteFunction","detach","splice"],"mappings":"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","file":"maquette.min.js","sourcesContent":["// Comment that is displayed in the API documentation for the maquette module:\n/**\n * Welcome to the API documentation of the **maquette** library.\n *\n * [[http://maquettejs.org/|To the maquette homepage]]\n */\n\"use strict\";\nvar NAMESPACE_W3 = 'http://www.w3.org/';\nvar NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\nvar NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n// Utilities\nvar emptyArray = [];\nvar extend = function (base, overrides) {\n    var result = {};\n    Object.keys(base).forEach(function (key) {\n        result[key] = base[key];\n    });\n    if (overrides) {\n        Object.keys(overrides).forEach(function (key) {\n            result[key] = overrides[key];\n        });\n    }\n    return result;\n};\n// Hyperscript helper functions\nvar same = function (vnode1, vnode2) {\n    if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n        return false;\n    }\n    if (vnode1.properties && vnode2.properties) {\n        if (vnode1.properties.key !== vnode2.properties.key) {\n            return false;\n        }\n        return vnode1.properties.bind === vnode2.properties.bind;\n    }\n    return !vnode1.properties && !vnode2.properties;\n};\nvar toTextVNode = function (data) {\n    return {\n        vnodeSelector: '',\n        properties: undefined,\n        children: undefined,\n        text: data.toString(),\n        domNode: null\n    };\n};\nvar appendChildren = function (parentSelector, insertions, main) {\n    for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n        var item = insertions[i];\n        if (Array.isArray(item)) {\n            appendChildren(parentSelector, item, main);\n        }\n        else {\n            if (item !== null && item !== undefined) {\n                if (!item.hasOwnProperty('vnodeSelector')) {\n                    item = toTextVNode(item);\n                }\n                main.push(item);\n            }\n        }\n    }\n};\n// Render helper functions\nvar missingTransition = function () {\n    throw new Error('Provide a transitions object to the projectionOptions to do animations');\n};\nvar DEFAULT_PROJECTION_OPTIONS = {\n    namespace: undefined,\n    eventHandlerInterceptor: undefined,\n    styleApplyer: function (domNode, styleName, value) {\n        // Provides a hook to add vendor prefixes for browsers that still need it.\n        domNode.style[styleName] = value;\n    },\n    transitions: {\n        enter: missingTransition,\n        exit: missingTransition\n    }\n};\nvar applyDefaultProjectionOptions = function (projectorOptions) {\n    return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n};\nvar checkStyleValue = function (styleValue) {\n    if (typeof styleValue !== 'string') {\n        throw new Error('Style values must be strings');\n    }\n};\nvar setProperties = function (domNode, properties, projectionOptions) {\n    if (!properties) {\n        return;\n    }\n    var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n    var propNames = Object.keys(properties);\n    var propCount = propNames.length;\n    var _loop_1 = function (i) {\n        var propName = propNames[i];\n        /* tslint:disable:no-var-keyword: edge case */\n        var propValue = properties[propName];\n        /* tslint:enable:no-var-keyword */\n        if (propName === 'className') {\n            throw new Error('Property \"className\" is not supported, use \"class\".');\n        }\n        else if (propName === 'class') {\n            propValue.split(/\\s+/).forEach(function (token) { return domNode.classList.add(token); });\n        }\n        else if (propName === 'classes') {\n            // object with string keys and boolean values\n            var classNames = Object.keys(propValue);\n            var classNameCount = classNames.length;\n            for (var j = 0; j < classNameCount; j++) {\n                var className = classNames[j];\n                if (propValue[className]) {\n                    domNode.classList.add(className);\n                }\n            }\n        }\n        else if (propName === 'styles') {\n            // object with string keys and string (!) values\n            var styleNames = Object.keys(propValue);\n            var styleCount = styleNames.length;\n            for (var j = 0; j < styleCount; j++) {\n                var styleName = styleNames[j];\n                var styleValue = propValue[styleName];\n                if (styleValue) {\n                    checkStyleValue(styleValue);\n                    projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                }\n            }\n        }\n        else if (propName !== 'key' && propValue !== null && propValue !== undefined) {\n            var type = typeof propValue;\n            if (type === 'function') {\n                if (propName.lastIndexOf('on', 0) === 0) {\n                    if (eventHandlerInterceptor) {\n                        propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\n                    }\n                    if (propName === 'oninput') {\n                        (function () {\n                            // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n                            var oldPropValue = propValue;\n                            propValue = function (evt) {\n                                evt.target['oninput-value'] = evt.target.value; // may be HTMLTextAreaElement as well\n                                oldPropValue.apply(this, [evt]);\n                            };\n                        }());\n                    }\n                    domNode[propName] = propValue;\n                }\n            }\n            else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n                if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                    domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                }\n                else {\n                    domNode.setAttribute(propName, propValue);\n                }\n            }\n            else {\n                domNode[propName] = propValue;\n            }\n        }\n    };\n    for (var i = 0; i < propCount; i++) {\n        _loop_1(i);\n    }\n};\nvar updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n    if (!properties) {\n        return;\n    }\n    var propertiesUpdated = false;\n    var propNames = Object.keys(properties);\n    var propCount = propNames.length;\n    for (var i = 0; i < propCount; i++) {\n        var propName = propNames[i];\n        // assuming that properties will be nullified instead of missing is by design\n        var propValue = properties[propName];\n        var previousValue = previousProperties[propName];\n        if (propName === 'class') {\n            if (previousValue !== propValue) {\n                throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n            }\n        }\n        else if (propName === 'classes') {\n            var classList = domNode.classList;\n            var classNames = Object.keys(propValue);\n            var classNameCount = classNames.length;\n            for (var j = 0; j < classNameCount; j++) {\n                var className = classNames[j];\n                var on = !!propValue[className];\n                var previousOn = !!previousValue[className];\n                if (on === previousOn) {\n                    continue;\n                }\n                propertiesUpdated = true;\n                if (on) {\n                    classList.add(className);\n                }\n                else {\n                    classList.remove(className);\n                }\n            }\n        }\n        else if (propName === 'styles') {\n            var styleNames = Object.keys(propValue);\n            var styleCount = styleNames.length;\n            for (var j = 0; j < styleCount; j++) {\n                var styleName = styleNames[j];\n                var newStyleValue = propValue[styleName];\n                var oldStyleValue = previousValue[styleName];\n                if (newStyleValue === oldStyleValue) {\n                    continue;\n                }\n                propertiesUpdated = true;\n                if (newStyleValue) {\n                    checkStyleValue(newStyleValue);\n                    projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                }\n                else {\n                    projectionOptions.styleApplyer(domNode, styleName, '');\n                }\n            }\n        }\n        else {\n            if (!propValue && typeof previousValue === 'string') {\n                propValue = '';\n            }\n            if (propName === 'value') {\n                var domValue = domNode[propName];\n                if (domValue !== propValue // The 'value' in the DOM tree !== newValue\n                    && (domNode['oninput-value']\n                        ? domValue === domNode['oninput-value'] // If the last reported value to 'oninput' does not match domValue, do nothing and wait for oninput\n                        : propValue !== previousValue // Only update the value if the vdom changed\n                    )) {\n                    domNode[propName] = propValue; // Reset the value, even if the virtual DOM did not change\n                    domNode['oninput-value'] = undefined;\n                } // else do not update the domNode, otherwise the cursor position would be changed\n                if (propValue !== previousValue) {\n                    propertiesUpdated = true;\n                }\n            }\n            else if (propValue !== previousValue) {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    throw new Error('Functions may not be updated on subsequent renders (property: ' + propName +\n                        '). Hint: declare event handler functions outside the render() function.');\n                }\n                if (type === 'string' && propName !== 'innerHTML') {\n                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                    }\n                    else if (propName === 'role' && propValue === '') {\n                        domNode.removeAttribute(propName);\n                    }\n                    else {\n                        domNode.setAttribute(propName, propValue);\n                    }\n                }\n                else {\n                    if (domNode[propName] !== propValue) {\n                        domNode[propName] = propValue;\n                    }\n                }\n                propertiesUpdated = true;\n            }\n        }\n    }\n    return propertiesUpdated;\n};\nvar findIndexOfChild = function (children, sameAs, start) {\n    if (sameAs.vnodeSelector !== '') {\n        // Never scan for text-nodes\n        for (var i = start; i < children.length; i++) {\n            if (same(children[i], sameAs)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n};\nvar nodeAdded = function (vNode, transitions) {\n    if (vNode.properties) {\n        var enterAnimation = vNode.properties.enterAnimation;\n        if (enterAnimation) {\n            if (typeof enterAnimation === 'function') {\n                enterAnimation(vNode.domNode, vNode.properties);\n            }\n            else {\n                transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n            }\n        }\n    }\n};\nvar nodeToRemove = function (vNode, transitions) {\n    var domNode = vNode.domNode;\n    if (vNode.properties) {\n        var exitAnimation = vNode.properties.exitAnimation;\n        if (exitAnimation) {\n            domNode.style.pointerEvents = 'none';\n            var removeDomNode = function () {\n                if (domNode.parentNode) {\n                    domNode.parentNode.removeChild(domNode);\n                }\n            };\n            if (typeof exitAnimation === 'function') {\n                exitAnimation(domNode, removeDomNode, vNode.properties);\n                return;\n            }\n            else {\n                transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                return;\n            }\n        }\n    }\n    if (domNode.parentNode) {\n        domNode.parentNode.removeChild(domNode);\n    }\n};\nvar checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n    var childNode = childNodes[indexToCheck];\n    if (childNode.vnodeSelector === '') {\n        return; // Text nodes need not be distinguishable\n    }\n    var properties = childNode.properties;\n    var key = properties ? (properties.key === undefined ? properties.bind : properties.key) : undefined;\n    if (!key) {\n        for (var i = 0; i < childNodes.length; i++) {\n            if (i !== indexToCheck) {\n                var node = childNodes[i];\n                if (same(node, childNode)) {\n                    if (operation === 'added') {\n                        throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\n                            'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                    }\n                    else {\n                        throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' +\n                            'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                    }\n                }\n            }\n        }\n    }\n};\nvar createDom;\nvar updateDom;\nvar updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n    if (oldChildren === newChildren) {\n        return false;\n    }\n    oldChildren = oldChildren || emptyArray;\n    newChildren = newChildren || emptyArray;\n    var oldChildrenLength = oldChildren.length;\n    var newChildrenLength = newChildren.length;\n    var transitions = projectionOptions.transitions;\n    var oldIndex = 0;\n    var newIndex = 0;\n    var i;\n    var textUpdated = false;\n    while (newIndex < newChildrenLength) {\n        var oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;\n        var newChild = newChildren[newIndex];\n        if (oldChild !== undefined && same(oldChild, newChild)) {\n            textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n            oldIndex++;\n        }\n        else {\n            var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n            if (findOldIndex >= 0) {\n                // Remove preceding missing children\n                for (i = oldIndex; i < findOldIndex; i++) {\n                    nodeToRemove(oldChildren[i], transitions);\n                    checkDistinguishable(oldChildren, i, vnode, 'removed');\n                }\n                textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                oldIndex = findOldIndex + 1;\n            }\n            else {\n                // New child\n                createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                nodeAdded(newChild, transitions);\n                checkDistinguishable(newChildren, newIndex, vnode, 'added');\n            }\n        }\n        newIndex++;\n    }\n    if (oldChildrenLength > oldIndex) {\n        // Remove child fragments\n        for (i = oldIndex; i < oldChildrenLength; i++) {\n            nodeToRemove(oldChildren[i], transitions);\n            checkDistinguishable(oldChildren, i, vnode, 'removed');\n        }\n    }\n    return textUpdated;\n};\nvar addChildren = function (domNode, children, projectionOptions) {\n    if (!children) {\n        return;\n    }\n    for (var i = 0; i < children.length; i++) {\n        createDom(children[i], domNode, undefined, projectionOptions);\n    }\n};\nvar initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n    addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\n    if (vnode.text) {\n        domNode.textContent = vnode.text;\n    }\n    setProperties(domNode, vnode.properties, projectionOptions);\n    if (vnode.properties && vnode.properties.afterCreate) {\n        vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);\n    }\n};\ncreateDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n    var domNode, i, c, start = 0, type, found;\n    var vnodeSelector = vnode.vnodeSelector;\n    if (vnodeSelector === '') {\n        domNode = vnode.domNode = document.createTextNode(vnode.text);\n        if (insertBefore !== undefined) {\n            parentNode.insertBefore(domNode, insertBefore);\n        }\n        else {\n            parentNode.appendChild(domNode);\n        }\n    }\n    else {\n        for (i = 0; i <= vnodeSelector.length; ++i) {\n            c = vnodeSelector.charAt(i);\n            if (i === vnodeSelector.length || c === '.' || c === '#') {\n                type = vnodeSelector.charAt(start - 1);\n                found = vnodeSelector.slice(start, i);\n                if (type === '.') {\n                    domNode.classList.add(found);\n                }\n                else if (type === '#') {\n                    domNode.id = found;\n                }\n                else {\n                    if (found === 'svg') {\n                        projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                    }\n                    if (projectionOptions.namespace !== undefined) {\n                        domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                    }\n                    else {\n                        domNode = vnode.domNode = document.createElement(found);\n                        if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\n                            // IE8 and older don't support setting input type after the DOM Node has been added to the document\n                            domNode.setAttribute(\"type\", vnode.properties.type);\n                        }\n                    }\n                    if (insertBefore !== undefined) {\n                        parentNode.insertBefore(domNode, insertBefore);\n                    }\n                    else {\n                        parentNode.appendChild(domNode);\n                    }\n                }\n                start = i + 1;\n            }\n        }\n        initPropertiesAndChildren(domNode, vnode, projectionOptions);\n    }\n};\nupdateDom = function (previous, vnode, projectionOptions) {\n    var domNode = previous.domNode;\n    var textUpdated = false;\n    if (previous === vnode) {\n        return false; // By contract, VNode objects may not be modified anymore after passing them to maquette\n    }\n    var updated = false;\n    if (vnode.vnodeSelector === '') {\n        if (vnode.text !== previous.text) {\n            var newVNode = document.createTextNode(vnode.text);\n            domNode.parentNode.replaceChild(newVNode, domNode);\n            vnode.domNode = newVNode;\n            textUpdated = true;\n            return textUpdated;\n        }\n    }\n    else {\n        if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n        }\n        if (previous.text !== vnode.text) {\n            updated = true;\n            if (vnode.text === undefined) {\n                domNode.removeChild(domNode.firstChild); // the only textnode presumably\n            }\n            else {\n                domNode.textContent = vnode.text;\n            }\n        }\n        updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n        updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n        if (vnode.properties && vnode.properties.afterUpdate) {\n            vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);\n        }\n    }\n    if (updated && vnode.properties && vnode.properties.updateAnimation) {\n        vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n    }\n    vnode.domNode = previous.domNode;\n    return textUpdated;\n};\nvar createProjection = function (vnode, projectionOptions) {\n    return {\n        update: function (updatedVnode) {\n            if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n            }\n            updateDom(vnode, updatedVnode, projectionOptions);\n            vnode = updatedVnode;\n        },\n        domNode: vnode.domNode\n    };\n};\n// The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.\nexports.h = function (selector) {\n    var properties = arguments[1];\n    if (typeof selector !== 'string') {\n        throw new Error();\n    }\n    var childIndex = 1;\n    if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n        childIndex = 2;\n    }\n    else {\n        // Optional properties argument was omitted\n        properties = undefined;\n    }\n    var text;\n    var children;\n    var argsLength = arguments.length;\n    // Recognize a common special case where there is only a single text node\n    if (argsLength === childIndex + 1) {\n        var onlyChild = arguments[childIndex];\n        if (typeof onlyChild === 'string') {\n            text = onlyChild;\n        }\n        else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n            text = onlyChild[0];\n        }\n    }\n    if (text === undefined) {\n        children = [];\n        for (; childIndex < argsLength; childIndex++) {\n            var child = arguments[childIndex];\n            if (child === null || child === undefined) {\n            }\n            else if (Array.isArray(child)) {\n                appendChildren(selector, child, children);\n            }\n            else if (child.hasOwnProperty('vnodeSelector')) {\n                children.push(child);\n            }\n            else {\n                children.push(toTextVNode(child));\n            }\n        }\n    }\n    return {\n        vnodeSelector: selector,\n        properties: properties,\n        children: children,\n        text: (text === '') ? undefined : text,\n        domNode: null\n    };\n};\n/**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\nexports.dom = {\n    /**\n     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n     * its [[Projection.domNode|domNode]] property.\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection.\n     * @returns The [[Projection]] which also contains the DOM Node that was created.\n     */\n    create: function (vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    },\n    /**\n     * Appends a new child node to the DOM which is generated from a [[VNode]].\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param parentNode - The parent node for the new child node.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n    append: function (parentNode, vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        createDom(vnode, parentNode, undefined, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    },\n    /**\n     * Inserts a new DOM node which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param beforeNode - The node that the DOM Node is inserted before.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n     * NOTE: [[VNode]] objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n    insertBefore: function (beforeNode, vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    },\n    /**\n     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n     * This means that the virtual DOM and the real DOM will have one overlapping element.\n     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and child nodes are preserved.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n     * may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n    merge: function (element, vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        vnode.domNode = element;\n        initPropertiesAndChildren(element, vnode, projectionOptions);\n        return createProjection(vnode, projectionOptions);\n    },\n    /**\n     * Replaces an existing DOM node with a node generated from a [[VNode]].\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param element - The node for the [[VNode]] to replace.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n    replace: function (element, vnode, projectionOptions) {\n        projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n        createDom(vnode, element.parentNode, element, projectionOptions);\n        element.parentNode.removeChild(element);\n        return createProjection(vnode, projectionOptions);\n    }\n};\n/**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\nexports.createCache = function () {\n    var cachedInputs;\n    var cachedOutcome;\n    return {\n        invalidate: function () {\n            cachedOutcome = undefined;\n            cachedInputs = undefined;\n        },\n        result: function (inputs, calculation) {\n            if (cachedInputs) {\n                for (var i = 0; i < inputs.length; i++) {\n                    if (cachedInputs[i] !== inputs[i]) {\n                        cachedOutcome = undefined;\n                    }\n                }\n            }\n            if (!cachedOutcome) {\n                cachedOutcome = calculation();\n                cachedInputs = inputs;\n            }\n            return cachedOutcome;\n        }\n    };\n};\n/**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\nexports.createMapping = function (getSourceKey, createResult, updateResult) {\n    var keys = [];\n    var results = [];\n    return {\n        results: results,\n        map: function (newSources) {\n            var newKeys = newSources.map(getSourceKey);\n            var oldTargets = results.slice();\n            var oldIndex = 0;\n            for (var i = 0; i < newSources.length; i++) {\n                var source = newSources[i];\n                var sourceKey = newKeys[i];\n                if (sourceKey === keys[oldIndex]) {\n                    results[i] = oldTargets[oldIndex];\n                    updateResult(source, oldTargets[oldIndex], i);\n                    oldIndex++;\n                }\n                else {\n                    var found = false;\n                    for (var j = 1; j < keys.length + 1; j++) {\n                        var searchIndex = (oldIndex + j) % keys.length;\n                        if (keys[searchIndex] === sourceKey) {\n                            results[i] = oldTargets[searchIndex];\n                            updateResult(newSources[i], oldTargets[searchIndex], i);\n                            oldIndex = searchIndex + 1;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        results[i] = createResult(source, i);\n                    }\n                }\n            }\n            results.length = newSources.length;\n            keys = newKeys;\n        }\n    };\n};\n/**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectorOptions   Options that influence how the DOM is rendered and updated.\n */\nexports.createProjector = function (projectorOptions) {\n    var projector;\n    var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n    projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n        return function () {\n            // intercept function calls (event handlers) to do a render afterwards.\n            projector.scheduleRender();\n            return eventHandler.apply(properties.bind || this, arguments);\n        };\n    };\n    var renderCompleted = true;\n    var scheduled;\n    var stopped = false;\n    var projections = [];\n    var renderFunctions = []; // matches the projections array\n    var doRender = function () {\n        scheduled = undefined;\n        if (!renderCompleted) {\n            return; // The last render threw an error, it should be logged in the browser console.\n        }\n        renderCompleted = false;\n        for (var i = 0; i < projections.length; i++) {\n            var updatedVnode = renderFunctions[i]();\n            projections[i].update(updatedVnode);\n        }\n        renderCompleted = true;\n    };\n    projector = {\n        renderNow: doRender,\n        scheduleRender: function () {\n            if (!scheduled && !stopped) {\n                scheduled = requestAnimationFrame(doRender);\n            }\n        },\n        stop: function () {\n            if (scheduled) {\n                cancelAnimationFrame(scheduled);\n                scheduled = undefined;\n            }\n            stopped = true;\n        },\n        resume: function () {\n            stopped = false;\n            renderCompleted = true;\n            projector.scheduleRender();\n        },\n        append: function (parentNode, renderMaquetteFunction) {\n            projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        insertBefore: function (beforeNode, renderMaquetteFunction) {\n            projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        merge: function (domNode, renderMaquetteFunction) {\n            projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        replace: function (domNode, renderMaquetteFunction) {\n            projections.push(exports.dom.replace(domNode, renderMaquetteFunction(), projectionOptions));\n            renderFunctions.push(renderMaquetteFunction);\n        },\n        detach: function (renderMaquetteFunction) {\n            for (var i = 0; i < renderFunctions.length; i++) {\n                if (renderFunctions[i] === renderMaquetteFunction) {\n                    renderFunctions.splice(i, 1);\n                    return projections.splice(i, 1)[0];\n                }\n            }\n            throw new Error('renderMaquetteFunction was not found');\n        }\n    };\n    return projector;\n};\n\n//# sourceMappingURL=maquette.js.map\n"]}